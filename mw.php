<?php
define("version", "1.01-beta");

// Init Default values for variables
$recursive = false;
$path = getcwd();
$learn = false;
$ignore = false;
$whitelist = "userWhitelist";

$shortopts="Ril:s:vq"; // R: Recursive, i: Ignore, l or w Learn and Whitelist, if present requires a value (undocumented s,v)
$longopts=array(
	"recursive","ignore","learn:","quiet");
$options = getopt($shortopts,$longopts,$optindex);

// Check for batch mode
if(isset($options["i"]) || isset($options["ignore"])){
	$ignore=true;
}
// Check for recursive
if(isset($options["R"]) || isset($options["recursive"])){
	$recursive=true;
}
// Silent mode
if(isset($options["q"]) || isset($options["quiet"])){
	define("VERBOSE",false);
}
else{
	define("VERBOSE",true);
}

// Do we learn ?
if(isset($options["l"]) && isset($options["learn"])) {
	echo "Error: Please use only one version of the learn flag".PHP_EOL;
	die();
}
else{
	if(isset($options["l"])){
		$whitelist=$options["l"];
		$learn=true;
		// In learning mode, there is no point to ask the user
		$ignore=true;
	}
	elseif (isset($options["learn"])){
		$whitelist=$options["learn"];
		$learn=true;
		// In learning mode, there is no point to ask the user
		$ignore=true;
	}
}

if(isset($options["s"])){
	$string=$options["s"];
	$mw = new MalWare('');
	$m = $mw->isHumanReadable($string, "strings");
	if($m) {
		echo "Error: Suspicious string content\n";
		var_dump($m);
	}
	die();
}
if(isset($options["v"])){
	$string=$options["v"];
	$mw = new MalWare('');
	$m = $mw->isHumanReadable($string, "variables");
	if($m) {
		echo "Error: Suspicious variable name\n";
	}
	die();
}

// Looking for path. Default is current working dir (see above)
if(isset($argv[$optindex])){
	$path=$argv[$optindex];
	if(!is_dir($path)){
		echo "Error: $path not found or unreadable".PHP_EOL;
		die();
	}
}

ini_set('memory_limit','1024M');
if(VERBOSE) {
	echo "Sergei Malware Finder\nversion " . version . "\nCopyright 2020. Serge Bayet\n\n";
	echo "Recursive: ".($recursive?"Yes":"No").PHP_EOL;
	echo "Learning: ".($learn?"Yes":"No").PHP_EOL.PHP_EOL;;
}

$mw = new Malware($path, $recursive, 'php', $ignore, $learn, $whitelist);
$mw->load();
$mw->scan();

die();

class Malware
{
  private $path;
  private $files;
  private $language;
  private $recursive;
  private $strs;
  private $vars;
  private $readableFrequency;
  private $ignore;
  private $whitelisted;
  private $rules;
  private $whitelist;
  private $learn;
  private $quarantine = [];
  private $warnings = [];
  private $out = [];
  private $whitelistedDetected = 0;
  private $totalPotentialMalicious = 0;
  function __construct($path, $recursive = false, $language = "php", $ignore = false, $learn = false, $whitelist = "userWhitelist") {
    $this->path = $path;
    $this->language = $language;
    $this->recursive = $recursive;
    $this->ignore = $ignore;
    $this->learn = $learn;
    $this->whitelist = $whitelist;
    $this->getReadableFrequency();

  }
  public function load() {
    $this->readDirectory($this->path, $this->recursive);
  }
  
  private function getReadableFrequency() {
    $this->readableFrequency = json_decode(file_get_contents("freq.json"), true);
    $this->rules = json_decode(file_get_contents("rules.json"), true);
    $this->whitelisted = json_decode(file_get_contents("whitelisted.json"), true);
    if(!isset($this->readableFrequency['whitelist']))
    {
      $this->readableFrequency['whitelist'] = ['T_STRING' => [], 'T_CONSTANT_ENCAPSED_STRING' => [], 'T_VARIABLE' => []];
    }
  }

  public function readDirectory($path, $recursive = false) {
    $files = glob( $path . '*', GLOB_MARK ); //GLOB_MARK adds a slash to directories returned
  
    foreach( $files as $file )
    {
      if(mb_substr($file,(-strlen($this->language) - 1)) == "." . $this->language) {
        $this->files[] = $file;
      }
      if($recursive && is_dir($file)) {
        $this->readDirectory( $file, true );
      }
    }
  }

  public function scan() {
    $n = count($this->files);
    $count = 0;
    foreach($this->files as $file) {
      
      $this->scanFile($file);
      $count++;
      if($this->ignore)
      {
        $this->progress_bar($count, $n, $file);
      }
    }
   
    echo "\n";
    if($this->ignore) {
      echo implode($this->out) . "\n";
    }
    if(VERBOSE) {
	    echo 'Total files scanned : ' . $n . "\n";
	    echo 'Total whitelisted detected file : ' . $this->whitelistedDetected . "\n";
	    echo 'Total potential malicious malware detected : ' . $this->totalPotentialMalicious . "/" . $n . "\n";
    }
  }

  public function scanFile($file) {
    $content = @file_get_contents($file);
    $passed = true;
    if(!$content) {
      echo "Can't open $file ...\n";
      return false;
    }
    if($this->ignore) {
      $this->out[] = "Analyzing " . substr($file, -114) . "...\n";
    }
    else
    {
      $output = "Analyzing " . substr($file, -114) . "...\n";
      echo $output;
    }
   
    $log['whitelisted'] = $this->examineWhitelisted($content);
    if(!empty($log['whitelisted'])) {
      if($this->ignore) {
        $this->out[] = "\n\033[32mWhitelisted file :\033[37m " . $log['whitelisted']['version'] . " => ".$log['whitelisted']['file']."\n";
      }
      else
      {
        echo "\n\033[32mWhitelisted file :\033[37m " . $log['whitelisted']['version'] . " => ".$log['whitelisted']['file']."\n";
      }
      $this->whitelistedDetected++;
      return true;
    }
    $log['alerts'] = $this->examineRules($content);
    if($log['alerts']['status'] !== "passed") {
      if(!$this->learn) {
        $this->dumpDetails($log['alerts']['details']);
      }
      $passed = false;   
    }
    
    $tokens = token_get_all($content);
    $log['suspicious_naming'] = $this->examineTokens($tokens, $file);
    $nSuspiciousNaming = count($log['suspicious_naming']);
    if( $nSuspiciousNaming > 0) {
      if(!$this->learn) {
        $this->dumpSuspiciousNamings($log['suspicious_naming']);
      }
      $passed = false;
    }
    if(!$passed && !$this->ignore) {
      $bn = basename($file);
      echo "\033[4mP\033[0mut $bn in quarantine\n\033[4mA\033[0mdd $bn to whitelist\n";
      if($nSuspiciousNaming > 0 ) {
        echo "\033[4mS\033[0mtore suspicious namings as valid namings\n";
      }
      echo "\033[4mI\033[0mgnore\n";
      echo "\033[4mQ\033[0muit\n\n";
      $char = $this->readChar("");
      switch($char) {
        case "s":
          $this->storeSuspiciousNamings($log['suspicious_naming']);
        break;
        case "a":
          $filename = substr($file, strlen($this->path));
          $sha = $this->getHash($content);
          $this->whitelisted[$this->whitelist][$filename] = $sha;
          file_put_contents("whitelisted.json", json_encode($this->whitelisted, JSON_PRETTY_PRINT));
          echo "Whitelisted\n";
        break;
        case "p":
          if(!is_dir(".quarantine")) {
            mkdir(".quarantine");
          }
          rename($file, ".quarantine/" . strval(time()) . "_" . basename($file));
          echo "put in quarantine\n";
        break;
        case "q":
          die("Goodbye!\n");
        default:
        break;
      }
      
    }
    if(!$passed && $this->learn) {
      // Add to white list
      $filename = substr($file, strlen($this->path));
     
      if($nSuspiciousNaming > 0) {
        $this->storeSuspiciousNamings($log['suspicious_naming']);
        echo "Namings learned\n";
      }
      if($log['alerts']['status'] !== "passed")
      {
        $sha = $this->getHash($content);
        $this->whitelisted[$this->whitelist][$filename] = $sha;
        file_put_contents("whitelisted.json", json_encode($this->whitelisted, JSON_PRETTY_PRINT));
        echo "Whitelisted\n";
      }
      //
    }
    if(!$passed) {
      $this->totalPotentialMalicious++;
    }
    return $passed;
  }
  
  public function readchar($prompt)
  {
      readline_callback_handler_install($prompt, function() {});
      $char = stream_get_contents(STDIN, 1);
      readline_callback_handler_remove();
      return strtolower($char);
  }
  public function examineWhitelisted($str) {
    $shaContent = $this->getHash($str);
    foreach($this->whitelisted as $key => $version) {
      foreach($version as $file => $sha) {
        
        if($sha == $shaContent) {
          return ['version' => $key, 'file' => $file];
        }
      }
    }
    return false;
  }
  public function examineRules($str) {
    $results = [];
    $examined = [];
    $nMalware = 0;
    $extractsToDisplay = [];
    //var_dump($this->rules);
    $len = strlen($str);
    
    foreach($this->rules as $ruleName => $rule) {
      
      $examined[$ruleName]['#filesize'] = $len;
      $match = 0;
      $private = false;
      $global = false;
      if(isset($rule['global']) && $rule['global']) {
        $global = true;
      }
      if(isset($rule['private']) && $rule['private']) {
        $private = true;
      }
      if(isset($rule['strings'])) {
        foreach($rule['strings'] as $stringName => $string)
        {
          $match = @preg_match_all($string . "u", $str, $matches, PREG_OFFSET_CAPTURE);
          if($match === false) {
            $match = @preg_match_all("/" . preg_quote($string) ."/u", $str, $matches, PREG_OFFSET_CAPTURE);
          }
          
          if( ($match !== false && $match)) {
            if(!$global)
            {
              $extracts[$ruleName][$stringName] = [];
              $strWithoutRn = $str; //preg_replace("/\n/u"," ", $str);
              foreach($matches[0] as $tok) {
                $lenTok = 30;
                $start = $tok[1] - $lenTok;
                if($start < 0) {
                  $lenTok = $lenTok + $start;
                  $start = 0;
                  
                }
                if(mb_strlen($tok[0]) > 80) {
                  $tok[0] = mb_substr($tok[0],0,80);
                  $extracts[$ruleName][$stringName][] = "..." . mb_substr($strWithoutRn, $start, $lenTok, 'UTF-8') . "\033[33m" . $tok[0] . "\033[37m...\n";
                }
                else
                {
                  $extracts[$ruleName][$stringName][] = "..." . mb_substr($strWithoutRn, $start, $lenTok, 'UTF-8') . "\033[33m" . $tok[0] . "\033[37m" . mb_substr($strWithoutRn, $tok[1] + mb_strlen($tok[0]), 30, 'UTF-8') . "...\n";

                }
              }
            }
            if(!isset($examined[$ruleName][$stringName]))
            {
              //
              $examined[$ruleName][$stringName] = $match;
            }
            else
            {
              $examined[$ruleName][$stringName]+= $match;
            }
          }
        }
      }
      
      if(isset($rule['condition'])) {
        $result = $this->testCondition($examined[$ruleName], $rule['condition']);
        //var_dump($rule['condition'], $result);
        if($global && !$result)
        {
          return ['status' => 'passed', 'info' => 'not a php file'];
        }
        
        if($result) {
          
          $results[] = $ruleName;
          if(!$global) {
            $nMalware++;
            $extractsToDisplay[$ruleName] = $extracts[$ruleName];
          }
          
        }
      }
      
    }

    //var_dump($results);
    switch($nMalware) {
      case 0:
        $status = "passed";
      break;
      
      default:
        $status = "critical";
      break;
    }
    return ['status' => $status, 'info' => '', 'details' => $extractsToDisplay];
  }
  public function testCondition($examined, $condition) {
    //var_dump($examined, $condition);
    $operator = "";
    $value = false;
    foreach($condition as $statement) {
      $calculate = false;
      if(is_string($statement)) {
        switch($statement) {
          case '$and':
            $operator = "and";
          break;
          case '$or':
            $operator = "or";
          break;
          case '<':
            $operator = "<";
          break;
          default:
            if(isset($examined[$statement]) ) {
              $rightOperand = $examined[$statement];
              $calculate = true;
            }
            else if(preg_match("/(\d*)M/", $statement, $matches)) {
              $rightOperand = intval($matches[1]) * 1024 * 1024;
              $calculate = true;
            }
            else if(preg_match("/(\d*|any) of them/", $statement, $matches)) {
              if($matches[1] == "any") {
                $n = 1;
              }
              else
              {
                $n = intval($matches[1]);
              }
              $rightOperand = count(array_filter($examined, function($x) {
                return substr($x,0,1) !== "#";
              }, ARRAY_FILTER_USE_KEY)) >= $n ? true : false;
              
              $calculate = true;
              
            }
            
        }
      } else if(is_array($statement)) {
        $rightOperand = $this->testCondition($examined, $statement);
        $calculate = true;
      }
      if($calculate) {
        switch ($operator) {
          case '':
           
            $value = $rightOperand;
          break;
          case 'and':
            $value = $value && $rightOperand;
          break;
          case 'or':
            $value = $value && $rightOperand;
          break;
          case '<':
            $value = $value < $rightOperand;
          break;
        }
      }
    }
    return $value;
  }
  public function examineTokens($tokens, $file) {
    $log = [];
    $tokens = array_map(function($x) {
      return is_array($x) ? [token_name($x[0]), $x[1], $x[2]] : [$x];
    },$tokens);
    
    $count = 0;
    foreach($tokens as $token) {
      $class = $token[0];
      $ret = "";
      
      switch($class) {
        case 'T_VARIABLE':
          $t = trim($token[1], "$");
          if(in_array($t, $this->readableFrequency['whitelist'][$class])) {
            break;
          }
          $ret = $this->isHumanReadable($t, 'variables', $file, $token[2]);
          
        break;
        case 'T_STRING':
          $t = trim($token[1], "\"'");
          if(in_array($t, $this->readableFrequency['whitelist'][$class])) {
            break;
          }
          $ret = $this->isHumanReadable($t, 'strings', $file, $token[2]);
        break;
        case 'T_CONSTANT_ENCAPSED_STRING':
          $t = trim($token[1], "\"'");
          if(in_array($t, $this->readableFrequency['whitelist'][$class])) {
            break;
          }
          $ret =$this->isHumanReadable($t, 'encapsed_strings', $file, $token[2]);
        break;

      }
      if($ret !== "") {
        $log[$class][] = $ret;
        
      }
    }
    return $log;
  }
 
  private function storeSuspiciousNamings($strs) {
    
    foreach($strs as $type => $str)
    {
      $arr = array_count_values($str);
      foreach($arr as $str => $n) {
        $this->readableFrequency['whitelist'][$type][] = $str;
      }
    }
    file_put_contents("freq.json", json_encode($this->readableFrequency, JSON_PRETTY_PRINT));
    //var_dump($this->readableFrequency['whitelist']);
  }
  public function dumpSuspiciousNamings($det) {
    $out = "";
    $out .= "\n";
    $out .= "\033[1mSuspicious names\033[0m detected!\n\n";
    foreach($det as $typeName => $type) {
      $out .= "   \033[4m" . $typeName."\033[0m => \n";
      $arr = array_count_values($type);
      $maxLength = max(array_map("strlen", array_keys($arr)));
      if($maxLength > 50) {
        $maxLength = 50;
      }
      $i = 0;
      foreach($arr as $string => $n)
      {
        if(strlen($string) > $maxLength) {
          $string = substr($string,0,$maxLength-3) . "...";
        }
        $out .= "      " . $string . str_repeat(" ", $maxLength - strlen($string)) . "  => $n ". ( $n > 1 ? "times" : "time") . "\n";
        $i++;
        if($i > 10) {
          $out .= "      \033[36m" . (count($arr) -10) . " more lines...\033[37m\n";
          break;
        } 
      }
      
      $out .= "\n";
    }
    $out .= "\n";
    if($this->ignore) {
      $this->out[] = $out;
      return;
    }
    echo $out;
  }
  public function dumpDetails($det) {
    $out = "";
    $out .= "\n";
    foreach($det as $ruleName => $details)
    {
      $out .= "\033[1m".$ruleName."\033[0m broken rules detected!\n\n";
      
      foreach($details as $key => $detail)
      {
        $out .= "   \033[4m" . $key."\033[0m => \n";
        $i = 0;
        foreach($detail as $extract) {
          $out .= "      " . preg_replace('/\s+/'," ", $extract) ."\n";
          $i++;
          if($i > 10) {
            $out .= "      \033[36m" . (count($detail) -10) . " more lines...\033[37m\n";
            break;
          } 
        
        }
      }
      $out .= "\n";
    }
    $out .= "\n";
    if($this->ignore) {
      $this->out[] = $out;
      return;
    }
    echo $out;
    
  }
  
  public function isHumanReadable($str, $type = "strings", $file = "", $line = 1) {
    $log = [];
    $originalType = $type;
    $originalStr = utf8_encode($str);
    $str = utf8_encode($str);

    
    // If the type is 'string encapsed' filter characters (regex expression for instance)

    if($type == "encapsed_strings") {

      if(preg_match("/^(\d+\.)?(\d+\.)?(\*|\d+)$/", $str)) {
        // Version number
        return "";
      }
      if(preg_match("/^\#([0-9a-fA-F]{3})([0-9a-fA-F]{3})?$/", $str)) {
        // CSS hex color number
        return "";
      }
      if(@preg_match($str, "") !== false) {
        // Regex detected
        return "";
      }
      $str = preg_replace('/\\\\\w/','', $str);
      $str = preg_replace('/%\w*/', '', $str);
      $str = preg_replace('/[^a-z0-9]/i', ' ', $str);
      // Big strings resolver
      $maxLength = max(array_map("strlen", explode(" ", $str)));
      if($maxLength > 26) {
        return $originalStr;
      }
      else
      {
        return "";
      }
      $type = "strings";
    }
    else if($type == "variables" || $type == "strings") {
      if(function_exists($str)) {
        return "";
      }
      
     
    }
    $str = preg_replace('/([a-z])([A-Z])/', '$1 $2', $str);
    $str = preg_replace('/([a-zA-Z])([0-9])/', '$1 $2', $str);
    $str = preg_replace('/([0-9])([a-zA-Z])/', '$1 $2', $str);

    $str = preg_replace('/\\_/',' ', $str);
    $str = trim($str);

    // Skip words with a length <= 2

    $len = mb_strlen($str);
    if($len <= 3) return "";

    // If the string is all in uppercase. Treat differently
    
    $uppercase = false;
    if(mb_strtoupper($str) == $str) {
      $uppercase = true;
    }
    else if( mb_strtoupper(mb_substr($str, 1,1) !== mb_substr($str, 1, 1)))
    {
      $str = lcfirst($str);
    }
    
    $chars = [];
    // Chunk sizes 
    for ($i = 2; $i < 3; $i++) {
        for ($j = 0; $j < $len; $j++) {
            if ($len > $j + $i) {
              
              $chunk = trim(mb_substr($str, $j, $i + 1));
              if($uppercase) {
                $chunk = mb_strtolower($chunk);
              }
              if($chunk == "") {
                continue;
              }
              $chars[$chunk] = isset($this->readableFrequency[$type]['freq'][$chunk]) ? $this->readableFrequency[$type]['freq'][$chunk] : 0;
            }
        }
    }
    usort($chars, function($x, $y) {
      return $x > $y;
    });
    $score = $chars[intval(count($chars) / 2)];
    
    if($score < 10) {
      
      //echo "Line : $line.  $originalType : '$str' : " . $score. "\n";
      
      return $originalStr; // . " (".$str.")";
    }
    //echo $str."\n";
    return "";
  }
  public function getHash($content) {
    return sha1($content);
  }
  public function progress_bar($done, $total, $info="", $width=20, $infoWidth = 60) {
    $perc = round(($done * 100) / $total);
    $bar = round(($width * $perc) / 100);
    $barFill = str_repeat("=", $bar);
    $emptyFill = str_repeat(" ", $width - $bar);
    $percFill = " " . $perc . "% ";
    if($bar >= strlen($percFill) + 2) {
      $position = ($bar / 2) - (strlen($percFill) + 2) / 2;
      $barFill = substr($barFill, 0, $position) . "\033[1m" . $percFill . "\033[0m" . substr($barFill, $position + strlen($percFill) + 2);
    }
    else
    {
      $position = (($width - $bar) / 2) - (strlen($percFill) + 4) / 2;
      $emptyFill = substr($emptyFill, 0, $position) . "\033[1m" . $percFill . "\033[0m" . substr($emptyFill, $position + strlen($percFill) + 2);
    }
    echo "\r[" . $barFill . ">" . $emptyFill . "]";
    if(strlen($info) > $infoWidth - 3) {
      $info = "..." . substr($info, - ($infoWidth-3));
    }
    $info = $info . str_repeat(" ", $infoWidth - strlen($info));
    echo " $info";
  }
}
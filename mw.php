<?php
ini_set('memory_limit','1024M');
echo "Sergei Malware Finder\nversion 1.0\nCopyright 2020. Serge Bayet\n\n";

// Slice the first argument which actually is "mw.php'

$argv = array_slice($argv, 1);

// Set the default options

$recursive = false;
$path = "";
$learn = false;
$test= false;
$ignore = false;
$whitelist = "userWhitelist";
$i = 0;
while(isset($argv[$i])) {
  switch($argv[$i]) {
    case '-lw':                                           // Learn and put in white list ("userWhitelist" or argument defined)
      if(isset($argv[$i + 1])) {
        $whitelist = $argv[$i+1];
        $i++;
      }
      $learn = true;
      $ignore = true;
    break;
    case '-R':
      $recursive = true;
      break;
    case '-s':
      if(isset($argv[$i + 1])) {
        $string = $argv[$i+1];
      }
      else {
        die("String argument missing");
      }
      $mw = new MalWare('');
      $m = $mw->isHumanReadable($string, "strings");
      if($m) {
        echo "Suspicious string content\n";
        var_dump($m);
      }
      die();
    break;
    case '-i':
      $ignore = true;
    break;
    case '-v':
      if(isset($argv[$i + 1])) {
        $string = $argv[$i+1];
      }
      else {
        die("Variable argument missing");
      }
      $mw = new MalWare('');
      $m = $mw->isHumanReadable($string, "variables");
      if($m) {
        echo "Suspicious variable name\n";
      }
      die();
    break;
    case '-t':
      $test = true;
    break;
    default:
      $path = $argv[$i];
  }
  $i++;
}

$mw = new Malware($path, $recursive, 'php', $test, $ignore, $learn, $whitelist);
$mw->load();
$mw->scan();

die();

class Malware
{
  private $test;
  private $path;
  private $files;
  private $language;
  private $recursive;
  private $strs;
  private $vars;
  private $readableFrequency;
  private $ignore;
  private $whitelisted;
  private $rules;
  private $whitelist;
  private $learn;
  private $quarantine = [];
  private $warnings = [];
  function __construct($path, $recursive = false, $language = "php", $test = false, $ignore = false, $learn = false, $whitelist = "userWhitelist") {
    $this->path = $path;
    $this->language = $language;
    $this->recursive = $recursive;
    $this->test = $test;
    $this->ignore = $ignore;
    $this->learn = $learn;
    $this->whitelist = $whitelist;
    $this->getReadableFrequency();

  }
  public function load() {
    $this->readDirectory($this->path, $this->recursive);
  }
  
  private function getReadableFrequency() {
    $this->readableFrequency = json_decode(file_get_contents("freq.json"), true);
    $this->rules = json_decode(file_get_contents("rules.json"), true);
    $this->whitelisted = json_decode(file_get_contents("whitelisted.json"), true);
    if(!isset($this->readableFrequency['whitelist']))
    {
      $this->readableFrequency['whitelist'] = ['T_STRING' => [], 'T_CONSTANT_ENCAPSED_STRING' => [], 'T_VARIABLE' => []];
    }
  }

  public function readDirectory($path, $recursive = false) {
    $files = glob( $path . '*', GLOB_MARK ); //GLOB_MARK adds a slash to directories returned
    foreach( $files as $file )
    {
      if(mb_substr($file,(-strlen($this->language) - 1)) == "." . $this->language) {
        $this->files[] = $file;
      }
      if($recursive && is_dir($file)) {
        $this->readDirectory( $file, true );
      }
    }
  }

  public function scan() {
    foreach($this->files as $file) {
      $this->scanFile($file);
    }
    echo "\n";
    
  }

  public function scanFile($file) {
    $content = @file_get_contents($file);
    $passed = true;
    if(!$content) {
      echo "Can't open $file ...\n";
      return false;
    }
    $output = "Analyzing " . substr($file, -114) . "...";
    echo $output;
    $log['whitelisted'] = $this->examineWhitelisted($content);
    if(!empty($log['whitelisted'])) {
      echo "\n\033[32mWhitelisted file :\033[37m " . $log['whitelisted']['version'] . " => ".$log['whitelisted']['file']."\n";
      return true;
    }
    $log['alerts'] = $this->examineRules($content);
    if($log['alerts']['status'] !== "passed") {
      if(!$this->learn) {
        $this->dumpDetails($log['alerts']['details']);
      }
      $passed = false;   
    }
    
    $tokens = token_get_all($content);
    $log['suspicious_naming'] = $this->examineTokens($tokens, $file);
    $nSuspiciousNaming = count($log['suspicious_naming']);
    if( $nSuspiciousNaming > 0) {
      if(!$this->learn) {
        $this->dumpSuspiciousNamings($log['suspicious_naming']);
      }
      $passed = false;
    }
    if(!$passed && !$this->ignore) {
      $bn = basename($file);
      echo "\033[4mP\033[0mut $bn in quarantine\n\033[4mA\033[0mdd $bn to whitelist\n";
      if($nSuspiciousNaming > 0 ) {
        echo "\033[4mS\033[0mtore suspicious namings as valid namings\n";
      }
      echo "\033[4mI\033[0mgnore\n";
      echo "\033[4mQ\033[0muit\n\n";
      $char = $this->readChar("");
      switch($char) {
        case "s":
          $this->storeSuspiciousNamings($log['suspicious_naming']);
        break;
        case "a":
          $sha = $this->getHash($content);
          $this->whitelisted[$this->whitelist][$filename] = $sha;
          file_put_contents("whitelisted.json", json_encode($this->whitelisted, JSON_PRETTY_PRINT));
          echo "Whitelisted\n";
        case "p":
          if(!is_dir(".quarantine")) {
            mkdir(".quarantine");
          }
          rename($file, ".quarantine/" . strval(time()) . "_" . basename($file));
          echo "put in quarantine\n";
        case "q":
          die("Goodbye!\n");
        default:
        break;
      }
      
    }
    if(!$passed && $this->learn) {
      // Add to white list
      $filename = substr($file, strlen($this->path));
     
      if($nSuspiciousNaming > 0) {
        $this->storeSuspiciousNamings($log['suspicious_naming']);
        echo "Namings learned\n";
      }
      if($log['alerts']['status'] !== "passed")
      {
        $sha = $this->getHash($content);
        $this->whitelisted[$this->whitelist][$filename] = $sha;
        file_put_contents("whitelisted.json", json_encode($this->whitelisted, JSON_PRETTY_PRINT));
        echo "Whitelisted\n";
      }
      //
    }
    return $passed;
  }
  
  public function readchar($prompt)
  {
      readline_callback_handler_install($prompt, function() {});
      $char = stream_get_contents(STDIN, 1);
      readline_callback_handler_remove();
      return strtolower($char);
  }
  public function examineWhitelisted($str) {
    $shaContent = $this->getHash($str);
    foreach($this->whitelisted as $key => $version) {
      foreach($version as $file => $sha) {
        
        if($sha == $shaContent) {
          return ['version' => $key, 'file' => $file];
        }
      }
    }
    return false;
  }
  public function examineRules($str) {
    $results = [];
    $examined = [];
    $nMalware = 0;
    $extractsToDisplay = [];
    //var_dump($this->rules);
    $len = strlen($str);
    
    echo "\n";
    foreach($this->rules as $ruleName => $rule) {
      
      $examined[$ruleName]['#filesize'] = $len;
      $match = 0;
      $private = false;
      $global = false;
      if(isset($rule['global']) && $rule['global']) {
        $global = true;
      }
      if(isset($rule['private']) && $rule['private']) {
        $private = true;
      }
      if(isset($rule['strings'])) {
        foreach($rule['strings'] as $stringName => $string)
        {
          $match = @preg_match_all($string, $str, $matches, PREG_OFFSET_CAPTURE);
          if($match === false) {
            $match = @preg_match_all("/" . preg_quote($string) ."/u", $str, $matches, PREG_OFFSET_CAPTURE);
          }
          
          if( ($match !== false && $match)) {
            if(!$global)
            {
              $extracts[$ruleName][$stringName] = [];
              $strWithoutRn = preg_replace("/\n/u"," ", $str);
              foreach($matches[0] as $tok) {
                $start = $tok[1] - 30;
                if($start < 0) {
                  $start = 0;
                }
                if(mb_strlen($tok[0]) > 50) {
                  $tok[0] = mb_substr($tok[0],0,50);
                  $extracts[$ruleName][$stringName][] = "..." . mb_substr($strWithoutRn, $start, 30, 'UTF-8') . "\033[33m" . $tok[0] . "\033[37m...\n";
                }
                else
                {
                  $extracts[$ruleName][$stringName][] = "..." . mb_substr($strWithoutRn, $start, 30, 'UTF-8') . "\033[33m" . $tok[0] . "\033[37m" . mb_substr($strWithoutRn, $tok[1] + mb_strlen($tok[0]), 30, 'UTF-8') . "...\n";

                }
              }
            }
            if(!isset($examined[$ruleName][$stringName]))
            {
              //
              $examined[$ruleName][$stringName] = $match;
            }
            else
            {
              $examined[$ruleName][$stringName]+= $match;
            }
          }
        }
      }
      
      if(isset($rule['condition'])) {
        $result = $this->testCondition($examined[$ruleName], $rule['condition']);
        //var_dump($rule['condition'], $result);
        if($global && !$result)
        {
          return ['status' => 'passed', 'info' => 'not a php file'];
        }
        
        if($result) {
          
          $results[] = $ruleName;
          if(!$global) {
            $nMalware++;
            $extractsToDisplay[$ruleName] = $extracts[$ruleName];
          }
          
        }
      }
      
    }

    //var_dump($results);
    switch($nMalware) {
      case 0:
        $status = "passed";
      break;
      
      default:
        $status = "critical";
      break;
    }
    return ['status' => $status, 'info' => '', 'details' => $extractsToDisplay];
  }
  public function testCondition($examined, $condition) {
    //var_dump($examined, $condition);
    $operator = "";
    $value = false;
    foreach($condition as $statement) {
      $calculate = false;
      if(is_string($statement)) {
        switch($statement) {
          case '$and':
            $operator = "and";
          break;
          case '$or':
            $operator = "or";
          break;
          case '<':
            $operator = "<";
          break;
          default:
            if(isset($examined[$statement]) ) {
              $rightOperand = $examined[$statement];
              $calculate = true;
            }
            else if(preg_match("/(\d*)M/", $statement, $matches)) {
              $rightOperand = intval($matches[1]) * 1024 * 1024;
              $calculate = true;
            }
            else if(preg_match("/(\d*|any) of them/", $statement, $matches)) {
              if($matches[1] == "any") {
                $n = 1;
              }
              else
              {
                $n = intval($matches[1]);
              }
              $rightOperand = count(array_filter($examined, function($x) {
                return substr($x,0,1) !== "#";
              }, ARRAY_FILTER_USE_KEY)) >= $n ? true : false;
              
              $calculate = true;
              
            }
            
        }
      } else if(is_array($statement)) {
        $rightOperand = $this->testCondition($examined, $statement);
        $calculate = true;
      }
      if($calculate) {
        switch ($operator) {
          case '':
           
            $value = $rightOperand;
          break;
          case 'and':
            $value = $value && $rightOperand;
          break;
          case 'or':
            $value = $value && $rightOperand;
          break;
          case '<':
            $value = $value < $rightOperand;
          break;
        }
      }
    }
    return $value;
  }
  public function examineTokens($tokens, $file) {
    $log = [];
    $tokens = array_map(function($x) {
      return is_array($x) ? [token_name($x[0]), $x[1], $x[2]] : [$x];
    },$tokens);
    
    $count = 0;
    foreach($tokens as $token) {
      $class = $token[0];
      $ret = "";
      
      switch($class) {
        case 'T_VARIABLE':
          $t = trim($token[1], "$");
          if(in_array($t, $this->readableFrequency['whitelist'][$class])) {
            break;
          }
          $ret = $this->isHumanReadable($t, 'variables', $file, $token[2]);
          
        break;
        case 'T_STRING':
          $t = trim($token[1], "\"'");
          if(in_array($t, $this->readableFrequency['whitelist'][$class])) {
            break;
          }
          $ret = $this->isHumanReadable($t, 'strings', $file, $token[2]);
        break;
        case 'T_CONSTANT_ENCAPSED_STRING':
          $t = trim($token[1], "\"'");
          if(in_array($t, $this->readableFrequency['whitelist'][$class])) {
            break;
          }
          $ret =$this->isHumanReadable($t, 'encapsed_strings', $file, $token[2]);
        break;

      }
      if($ret !== "") {
        $log[$class][] = $ret;
        
      }
    }
    return $log;
  }
  public function explainLog($file, $log) {
    //var_dump(json_encode($log, JSON_PRETTY_PRINT));
    //die();
    $malware = 0;
    $totalWarnings = 0;
    $totalSuspicious = 0;
    foreach($log as $line => $w)
    {
      $nSuspicious = isset($w['suspicious']) ? count($w['suspicious']) : 0;
      $nWarnings = isset($w['warnings']) ? count($w['warnings']) : 0;
      $totalWarnings += $nWarnings;
      $totalSuspicious += $nSuspicious;
      if($nWarnings > 0) {
        if(!$this->test) {
          //var_dump($w);
          echo "\n\n*** Danger in line $line ".implode(";", $w['warnings'])."\n\n";
          $this->displayLine($file, $line);
        }
        $malware++;
      }
    }
    if($malware > 0) {
      
      echo "\nSuspicious file (suspicious naming : $totalSuspicious, warnings : $totalWarnings)\n";
      if(!$this->test)
      {
        readline("Put in quarantine?");
      }
      echo "\n";
    }
    else {
      echo "                                                                 \r";
    }
    //echo "\n";
  }
  private function storeSuspiciousNamings($strs) {
    
    foreach($strs as $type => $str)
    {
      $arr = array_count_values($str);
      foreach($arr as $str => $n) {
        $this->readableFrequency['whitelist'][$type][] = $str;
      }
    }
    file_put_contents("freq.json", json_encode($this->readableFrequency, JSON_PRETTY_PRINT));
    //var_dump($this->readableFrequency['whitelist']);
  }
  public function dumpSuspiciousNamings($det) {
    echo "\n";
    echo "\033[1mSuspicious names\033[0m detected!\n\n";
    foreach($det as $typeName => $type) {
      echo "   \033[4m" . $typeName."\033[0m => \n";
      $arr = array_count_values($type);
      $maxLength = max(array_map("strlen", array_keys($arr)));
      if($maxLength > 50) {
        $maxLength = 50;
      }
      $i = 0;
      foreach($arr as $string => $n)
      {
        if(strlen($string) > $maxLength) {
          $string = substr($string,0,$maxLength-3) . "...";
        }
        echo "      " . $string . str_repeat(" ", $maxLength - strlen($string)) . "  => $n ". ( $n > 1 ? "times" : "time") . "\n";
        $i++;
        if($i > 10) {
          echo "      \033[36m" . (count($arr) -10) . " more lines...\033[37m\n";
          break;
        } 
      }
      
      echo "\n";
    }
    echo "\n";
  }
  public function dumpDetails($det) {
    echo "\n";
    foreach($det as $ruleName => $details)
    {
      echo "\033[1m".$ruleName."\033[0m broken rules detected!\n\n";
      
      foreach($details as $key => $detail)
      {
        echo "   \033[4m" . $key."\033[0m => \n";
        $i = 0;
        foreach($detail as $extract) {
          echo "      " . preg_replace('/\s+/'," ", $extract) ."\n";
          $i++;
          if($i > 10) {
            echo "      \033[36m" . (count($detail) -10) . " more lines...\033[37m\n";
            break;
          } 
        
        }
      }
      echo "\n";
    }
    echo "\n";
  }
  public function displayLine($file, $line) {
    $all_lines = file($file);
    $code = preg_replace('/\s+/'," ", $all_lines[$line-1]);
    if(mb_strlen($code) > 77) {
      $code = mb_substr($code, 0, 77) . "\033[37m...\033[33m";
    }
    $before = isset($all_lines[$line-4]) ? $line - 4 : 0;
    for($i = $before; $i < $line - 1; $i++)
    {
      $b = preg_replace('/\s+/'," ", $all_lines[$i]);
      echo mb_strlen($b) > 80 ? mb_substr($b,0,77) . "..." : $b;
      echo "\n";
    }

    $code = "\033[33m" . $code . "\n\033[37m";
    echo $code;
    $after = $line;
    while($after < $line + 3 )
    {
      if(!isset($all_lines[$after])) {
      break;
      }
      $b = preg_replace('/\s+/'," ", $all_lines[$after]);
      echo mb_strlen($b) > 80 ? mb_substr($b,0,77) . "..." : $b;
      echo "\n";
      $after++;
    }
    
  }
  public function isHumanReadable($str, $type = "strings", $file = "", $line = 1) {
    $log = [];
    $originalType = $type;
    $originalStr = utf8_encode($str);
    $str = utf8_encode($str);

    
    // If the type is 'string encapsed' filter characters (regex expression for instance)

    if($type == "encapsed_strings") {

      if(preg_match("/^(\d+\.)?(\d+\.)?(\*|\d+)$/", $str)) {
        // Version number
        return "";
      }
      if(preg_match("/^\#([0-9a-fA-F]{3})([0-9a-fA-F]{3})?$/", $str)) {
        // CSS hex color number
        return "";
      }
      if(@preg_match($str, "") !== false) {
        // Regex detected
        return "";
      }
      $str = preg_replace('/\\\\\w/','', $str);
      $str = preg_replace('/%\w*/', '', $str);
      $str = preg_replace('/[^a-z0-9]/i', ' ', $str);
      // Big strings resolver
      $maxLength = max(array_map("strlen", explode(" ", $str)));
      if($maxLength > 26) {
        return $originalStr;
      }
      else
      {
        return "";
      }
      $type = "strings";
    }
    else if($type == "variables" || $type == "strings") {
      if(function_exists($str)) {
        return "";
      }
      
     
    }
    $str = preg_replace('/([a-z])([A-Z])/', '$1 $2', $str);
    $str = preg_replace('/([a-zA-Z])([0-9])/', '$1 $2', $str);
    $str = preg_replace('/([0-9])([a-zA-Z])/', '$1 $2', $str);

    $str = preg_replace('/\\_/',' ', $str);
    $str = trim($str);

    // Skip words with a length <= 2

    $len = mb_strlen($str);
    if($len <= 3) return "";

    // If the string is all in uppercase. Treat differently
    
    $uppercase = false;
    if(mb_strtoupper($str) == $str) {
      $uppercase = true;
    }
    else if( mb_strtoupper(mb_substr($str, 1,1) !== mb_substr($str, 1, 1)))
    {
      $str = lcfirst($str);
    }
    
    $chars = [];
    // Chunk sizes 
    for ($i = 2; $i < 3; $i++) {
        for ($j = 0; $j < $len; $j++) {
            if ($len > $j + $i) {
              
              $chunk = trim(mb_substr($str, $j, $i + 1));
              if($uppercase) {
                $chunk = mb_strtolower($chunk);
              }
              if($chunk == "") {
                continue;
              }
              $chars[$chunk] = isset($this->readableFrequency[$type]['freq'][$chunk]) ? $this->readableFrequency[$type]['freq'][$chunk] : 0;
            }
        }
    }
    usort($chars, function($x, $y) {
      return $x > $y;
    });
    $score = $chars[intval(count($chars) / 2)];
    
    if($score < 10) {
      
      //echo "Line : $line.  $originalType : '$str' : " . $score. "\n";
      
      return $originalStr; // . " (".$str.")";
    }
    //echo $str."\n";
    return "";
  }
  public function getHash($content) {
    return sha1($content);
  }
  public function progress_bar($done, $total, $info="", $width=50) {
    $perc = round(($done * 100) / $total);
    $bar = round(($width * $perc) / 100);
    echo substr(" " . $perc, -3)."%[" . str_repeat("=", $bar) . ">" . str_repeat(" ", $width - $bar) . "]\r";
  }
}